# Instructions

Please follow these steps to complete the study.

## 1. Demographics (Required)

Please complete the questionnaire below before moving on to the next step. This 
information will be used solely for analysis and will not be made public.

[**→ Demographics Questionnaire**](https://docs.google.com/forms/d/1Iqg3z3dGobO6GZey6Czp5DPCdaAv9uf0YsC6eRVtcQU/edit)

## 2. Build a Timer Application with ReactGenie
> To help you complete the development faster, we provide you with the tutorial and some 
snippets, which you can refer to complete the experimental tasks.

### 2.1 Requirements
Build a simple timer app that supports basic operations such as starting and pausing the timer. 
Refer to the UI screenshots below. Additionally, use ReactGenie to integrate voice commands to 
allow multimodality for users. 

This is the UI of a Timer.
<img style={{display:"inline-block"}} src="/TimerMain.png" width="45%"/>

<img style={{display:"inline-block"}} src="/TimerForm.png" width="45%"/>

User might use these multimodal interactions:


* User says "Create a new timer for 2 minutes." (with pic 1)
* User says "Delete this time", then click on the timer list.(with pic 1)
* User says "Show me all the default timer."(with pic 1)
* User says "Start all timers."(with pic 1)

* User says "Set the time to one and a half hours."(with pic 2)

### 2.2 Get Started with Boilerplate
#### 2.2.1 Clone Repository
We have put together some starter code for you in the `ReactGenieBoilerplate` repo. 
Clone ReactGenie's boilerplate from GitHub to a local Timer folder using the command as 
shown below:

```bash filename="run in bash" copy
git clone git@github.com:StanfordHCI/ReactGenieBoilerplate.git Timer
```
Then change the application name in `app.config.js` and `package.json` to `Timer`.
For example:

```json filename="package.json" {2} copy
{
    "name": "Timer",
    //"name": "template",
    "version": "0.0.1",
    "main": "__generated__/AppEntry.js",
    //...
}
```
```javascript  filename="app.config.js" {3, 5} copy
export default {
    expo: {
        name: "Timer",
        //name: "template",
        slug: "Timer",
        //slug: "template",
    //...
    }
    //...
}
```

#### 2.2.2 Set up .env and dependencies.
Please ensure that you have the latest version of `reactgenie-lib` in `package.json`. 
You can view the latest version of `reactgenie-lib` through the link blow.

[**→ reactgenie-lib**](https://www.npmjs.com/package/reactgenie-lib).
```json filename="package.json" {4} copy
{
    "dependencies": {
        //...
        "reactgenie-lib": "",// should be latest version
       //...
    },
}
```

Update your own API Keys for Azure and Open AI.
You can just copy the file `.env.example` on the Desktop to Timer folder and rename it to `.env` 
If you can not find `.env.example`, please contact us to get it.

```bash filename=".env"
AZURE_SPEECH_REGION=...key...
AZURE_SPEECH_KEY=...key...
OPENAI_API_BASE_URL=...key...
OPENAI_API_KEY=...key...
```
#### 2.2.3 Run the Application
You can run project with following commands:

```bash copy
npm install 
npx expo start --web
```
If there are any errors related to dependencies, you can delete the `node_modules` folder 
and run the command again.

You should see the below content:

```
1
dataclass template HelperTemp
HelperClass Template
```

Test the voice recognition feature by clicking on the microphone and saying something. This indicates that you can use ReactGenie normally and can 
start building the Timer.

### 2.3 TimerApp with ReactGenie Overview

There are three parts that need to be completed to build the Timer App with ReactGenie:
    1. **State Code**: In the `genie` folder, implement state that controls and manages the Timer
    2. **UI Code**: In the `src` file, implement the UI for displaying Timer
    3. **Combine**: Link the State and UI code in `App.tsx` and `store.ts`.

The state code contains necessary classes for data management and logic control, 
while the UI code is responsible for building the user interface. 

```bash
-genie
    - //state code
-src
    - //UI code
-App.tsx
-store.ts
```

To integrate this with React, you will need to
    - wrap the classes with **ReactGenie** decorators for related classes or members 
    - add example voice inputs to **State code**
    - bound data types to the **UI code**
With this setup, ReactGenie will generate commands and execute them automatically when users input voice.
The execution results will be displayed automatically by ReactGenie with respect to the bounded UI interface.

We'll provide more detailed instructions in the later sections and 
you can also reference the React Genie documentation for more guidance.

**Our Recommendation:**
First plan and implement the state code. Plan the classes that will be needed. After this, 
implement the UI and integrate the state code with the UI. Then you can test the app.

In the below section, we'll demonstrate how to implement state with ReactGenie for a simple Counter App. Use 
this as reference to build the state for the Timer app. You can refer to the Requirements section earlier in these docs 
to outline the necessary elements. 

### 2.4 Write State Code

#### 2.4.1 Create Classes
We'll show you how to build classes with ReactGenie below with a simple Counter App. You can use this as a reference as you 
consider which classes you'll need to implement for a Timer app. We'll also demonstrate usage of ReactGenie decorators for 
relevant classes.

> For Counter app, we'll create a Counter class. Initialize file `Counter.ts` under `genie` folder:
```bash
-genie
    -Counter.ts
```

There are four decorators in ReactGenie: **@GenieClass**, **@GenieKey**, **@GenieProperty**, **@GenieFunction**.

**@GenieClass** allows you to declare basic information about the class by adding a description. GenieClass provides 
two types of classes that can be inherited: **DataClass** and **HelperClass**. 
<font color='red'>**Please avoid directly inheriting from GenieClass !**</font>

**DataClass** is the basic unit for data management, and an instance of a DataClass can be viewed as a record in a database. 
The properties in a DataClass can be a number, string, boolean, DataClass, HelperClass or a list. Complex data 
types in DataClass will be stored using HelperClass, otherwise they cannot be serialized and stored correctly.

**HelperClass** is an auxiliary data storage helping the DataClass manage complex data types. 
The properties in a HelperClass can be a number, string, boolean, DataClass, or HelperClass, or a list. 

For example, if you wanted to record an order and time, you could create an **Order (DataClass)** to store
the information and a **DateTime (HelperClass)** to manage date. **(Because you cannot put a instance of Date in 
DataClass.)**

> For a Counter, we need the DataClass.
```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
}
```

ReactGenie also provides some preset classes and automatically generated functions, we will introduce them 
in section **2.4.3**.

#### 2.4.2 Decorators
ReactGenie offers three kinds of decorators.

**@GenieKey**: GenieKey is the identifier used by ReactGenie for data management, 
and each DataClass requires a GenieKey. There are no GenieKey in a HelperClass. 
When creating a new instance of DataClass, you must provide an exclusive GenieKey.
This key will allow you to access the object.

**@GenieProperty**: GenieProperty allows user to add description to a property. 
If you wish not to serialize a property, you can add an underscore (`_`) to prevent it. 

> For Counter, we use id as its key and create other two properties: type and count.
```typescript filename="Counter.ts" {6,7}
import { GenieClass, DataClass } from "reactgenie-lib";
import { GenieKey, GenieProperty } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    @GenieKey
    @GenieProperty("The id of Counter")
    public id: number;
    @GenieProperty("The type of Counter")
    public type: string;
    @GenieProperty("The count number")
    public count: number;
    //...
}
```

**@GenieFunction**: GenieFunction can be called by ReactGenie automatically during multimodal interactions. 
You can add a description to state what this function is used for. 

Notice:
1. Use of destructuring parameters for each function.
```typescript
// without Destructuring
example(a:number, b:number){}
// with Destructuring
example({a, b}:{a:number, b:number}){}
```
2. The constructor() should not be decorated by **@GenieFunction**
3. Each @GenieFunction needs an explicit return value.

> In our Counter class, we implement increment() and decrement() methods.

```typescript filename="Counter.ts" {11,16}
import { GenieClass, DataClass } from "reactgenie-lib";
import { GenieFunction } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    constructor({id, type}:{id:number, type:string}){
        //...
    }

    @GenieFunction("Increase the number")
    increment(): void {
        //...
    }

    @GenieFunction("Decrease the number")
    decrement(): void {
        //...
    }
}
```

#### 2.4.3 Preset Functions and Classes

ReactGenie also provides some preset classes and functions. You can use these for faster development.

**CreateObject(), GetObject(), DeleteObject()**

ReactGenie provides the above three operations for an object, among which GetObject and DeleteObject are only applicable to 
DataClass objects. 

CreateObject() will call the constructor of the class. Please use CreateObject instead of `new` when initializing a new object 
to ensure that the object is correctly serialized. 
<font color="red">And you need to implement your own create function based on CreateObject. </font>

Additionally, you can use GenieKey to get and delete the created object.

> We need to add our own object-related method to Counter
```typescript filename="Counter.ts" {9,15,20}
import { GenieClass, DataClass } from "reactgenie-lib";
import { GenieFunction } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    @GenieFunction()
    static CreateCounter({id, type}:{id:number, type:string}): Counter{
        Counter.CreateObject({id:id, type:type})
        return Counter.GetObject({id:id})
    }

    @GenieFunction()
    static GetCounter({id}:{id:number}): Counter{
        return Counter.GetObject({id:id})
    }

    @GenieFunction()
    DeleteCounter(): void{
        Counter.DeleteObject({id:this.id})
    }
}
```

**setup()**

The setup function is a static function of the GenieClass. You can override the setup function for initial program
 setup. ReactGenie will automatically call the function to complete the initialization. 
 
> For counter, we can set up three counters in the initialization.
```typescript filename="Counter.ts" {4}
@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    static setup() {
        Counter.CreateCounter({id:1, type:"apple"});
        Counter.CreateCounter({id:2, type:"orange"});
        Counter.CreateCounter({id:3, type:"banana"});
    }
}
```

**All(), Current()**

All() can get an array of all instances of a specific class and 
Current() can get the currently active target based on user clicks. 

You may not need Current() when writing state code, but you may use it when providing prompt examples.

Only dataclass has All() and Current().

> For example, you can automatically update the id for a new counter
```typescript filename="Counter.ts" {6}
@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    @GenieFunction()
    static CreateCounter({type}:{type:string}): Counter{
        const id = Counter.All().length + 1;
        Counter.CreateObject({id:id, type:type})
        return Counter.GetObject({id:id})
    }
    //...
}
```

<font color='red'>ReactGenie has two preset class **DateTime** and **TimeDelta**, they are both **HelperClass** objects. 
You can use these to help you build the Timer or you can build your own time management.</font> You can check the **Preset Class** section to get more information about them.

Here we list some function you might need.
```typescript filename="TimeDelta"
//property
    public hour: number;    // an integer representing hours
    public minute: number;  // an integer representing minutes
    public second: number;  // an integer representing seconds
//functions

// Returns a new instance of TimeDelta.
// Arguments are optional, defaults are 0 if not provided. 
// Use to create a new instance of TimeDelta
CreateTimeDelta({ year?: number, month?: number, day?: number, 
hour?: number, minute?: number, second?: number}) : TimeDelta;

// Adds an offset to a TimeDelta instance.
// All arguments are optional and are added to the properties of the instance
addOffset({hour?: number, minute?: number, second?: number});

// Returns the total amount of time left in seconds.
getLeftSecond():number;
```
```typescript filename="DateTime"
static today() : DateTime // Returns today's date as a DateTime object
```
### 2.5 Write UI code
After completing the state code, we need to consider what kind of interactive UI 
to build. We recommend considering the data content displayed when constructing the page.

> For Counter, we may need an UI to display the content of a counter, and an UI to display 
a list of counters. They correspond to an object and a list of objects.

```bash
-src
    -CounterView.tsx
    -CounterListView.tsx
```


To save your development time, we provide you with UI-related snippets in the code snippets tab of this documentation. 
Please refer to that for React and CSS code for the Timer app.

### 2.6 Link UI to State Code

After you complete the state code and UI code, you need to bind them together using **GenieClassInterface()** and 
set up the initialization of ReactGenie. You need to annotate the data type used for display in the corresponding UI,
 so that when ReactGenie gets the executed results, it will choose the UI to display according to the result type.

> For example, we can bind it like following:
```typescript filename="CounterView.tsx" {9,10}
const CounterViewImpl = (props: { name: string}) => {
    return (
        <div>
        //...
        </div>
    )
}

export const CounterView = GenieClassInterface((counter: Counter) => 
            `${counter.name} Counter`, "Counter", 1)(CounterViewImpl)
```
```typescript filename="CounterListView.tsx" {9}
const CounterListViewImpl = (props: { elements: { name: string }[] }) => {
    return (
        <div>
        //...
        </div>
    )
}

export const CounterListView = GenieClassInterface("Counter", "Counter[]")(CounterListViewImpl)
```

Then you need to include the main UI framework in `App.tsx`. ReactGenie UI must be implemented in `ModalityProvider`,
```typescript filename="App.tsx" {10} copy
<ModalityProvider
        examples={}//example prompt
        displayTranscript={true}
        codexApiKey={ENV.OPENAI_API_KEY!}
        codexApiBaseUrl={ENV.OPENAI_API_BASE_URL!}
        azureSpeechRegion={ENV.AZURE_SPEECH_REGION!}
        azureSpeechKey={ENV.AZURE_SPEECH_KEY!}
        extraPrompt={''}// extra prompt
      >
        // Your own UI
</ModalityProvider>
```

And then you need to modify `store.ts` to finish initialization. 

If you overload the `setup()` function in the class, it will be automatically called in `initReactGenie()`. 
If you want to manually complete the initialization, call your initialization function after `initReactGenie()`.

```typescript filename="store.ts" copy
export const reactGenieStore = initReactGenie();
//manul set up here
//Data1.manul_setup()
//Data2.manul_setup()
```
You can also rename `stroe.ts` to whatever you want, but don't forget to import it in `App.tsx`


### 2.7 Add Examples and Test
Finally, you need to add usage instances for your program to help LLM correctly generate 
executable results. You can provide examples of relevant function usage in each class and then add it to ModalityProvider.

> For counters, it may be just like this:
```typescript filename="Counter.ts"
export const CounterExamples = [
{
    user_utterance: "increment",
    example_parsed: "Counter.Current().increment()",
},
{
    user_utterance: "show me all vegetables counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "vegetable")',
},
{
    user_utterance: "increase me all fruit counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "fruit").increment()',
}]
```
```typescript filename="App.tsx" copy
import { CounterExamples } from "./genie/counter";

<ModalityProvider
        examples={CounterExamples}//example prompt
        //...
```

Notice:
1. The parameters in the cases should not be Destructuring
```typescript
//Right
"Couter.CreateCounter(type:\"fruit\")" 
//Wrong
//"Couter.CreateCounter({type:\"fruit\"})"
```

2. ReactGenie supports some filtering operations on arrays.

**matching(field, value), equal(field, value)**

**between(field, from, to), sort(field, ascending)**
Note that the field passed to sort() and between() should have a static compare() function.

**contains(field, value)**
The contains() returns the member whose field value contains the given value.

All this filtering operations return a array.

3. ReactGenie supports some querying operations on arrays.

ReactGenie allows developers to access the properties and functions of list members during execution. 
This can be used directly to access the properties of the list members.

```typescript copy
{
    user_utterance: "Show me all counters type",
    example_parsed: 'Counter.All().type',
  },
  {
    user_utterance: "Delete all fruit counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "fruit").DeleteCounter()',
  },
```



## 3. Questionnaire 
Before concluding the study, we would appreciate your feedback on the experiment and the ReactGenie library. Please complete the questionnaire below.

<font color='red'>Edit link</font>
[**→ Questionnaire for Developer Study**](https://docs.google.com/forms/d/e/1FAIpQLSfns89iM7uSktc2DTEOpl4KEXrf3S3myB3Oq3d0Cprnw-EurQ/viewform?usp=sf_link)