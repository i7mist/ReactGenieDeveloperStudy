# Instructions

Please follow these steps to complete the study.


## 1. Demographics (Required)

Please complete the questionnaire below before moving on to the next step. This 
information will be used solely for analysis and will not be made public.

[**→ Demographics Questionnaire**](https://docs.google.com/forms/d/e/1FAIpQLSeFwfHZ20AdljQREseuwGXhjmeYjfKiW2TwGa5zRi5_w56vhw/viewform?usp=sf_link)

## 2. Build a Timer Application with ReactGenie
> To help you complete the development faster, we provide you with the tutorial and some 
snippets, which you can refer to complete the experimental tasks. 

<font color="red">Please ensure that you have carefully read the content of each 
instruction before operating, especially pay attention to the notice part, as it 
contains important details related to the implementation.</font>

### 2.1 Requirements
Build a simple timer app that supports basic operations such as starting and pausing the timer. 
Refer to the UI screenshots below. Additionally, use ReactGenie to integrate voice commands to 
allow multimodality for users. 

Users may use a variety of possible interactions, consider the interactions that the user may 
make to build the entire application, we have given five possible user interaction inputs.

This is the UI of a Timer.
<img style={{display:"inline-block"}} src="/TimerMain.png" width="45%"/>

<img style={{display:"inline-block"}} src="/TimerForm.png" width="45%"/>

User might use these multimodal interactions:


* User says "Create a new timer for 2 minutes." (with pic 1)
* User says "Delete this time", then click on the timer list.(with pic 1)
* User says "Show me all the default timer."(with pic 1)
* User says "Start all timers."(with pic 1)

* User says "Set the time to one and a half hours."(with pic 2)

### 2.2 Get Started with Boilerplate

#### 2.2.1 Clone Repository
We have put together some starter code for you in the `ReactGenieBoilerplate` repo. 
Clone ReactGenie's boilerplate from GitHub to a local Timer folder using the command as 
shown below:

```bash filename="run in bash" copy
git clone git@github.com:StanfordHCI/ReactGenieBoilerplate.git Timer
```
Then change the application name in `package.json` and `app.config.js` to `Timer`.
For example:

```json filename="package.json" {2} copy
{
    "name": "Timer",
    //"name": "template",
    "version": "0.0.1",
    "main": "__generated__/AppEntry.js",
    //...
}
```
```javascript  filename="app.config.js" {3, 5} copy
export default {
    expo: {
        name: "Timer",
        //name: "template",
        slug: "Timer",
        //slug: "template",
    //...
    }
    //...
}
```

#### 2.2.2 Set up .env and dependencies.
Please ensure that you have the latest version of `reactgenie-lib` in `package.json`. 
You can view the latest version of `reactgenie-lib` through the link blow.

[**→ reactgenie-lib**](https://www.npmjs.com/package/reactgenie-lib).
```json filename="package.json" {4} copy
{
    "dependencies": {
        //...
        "reactgenie-lib": "",// should be latest version
       //...
    },
}
```

Update your own API Keys for Azure and Open AI.
You can just copy the file `.env.example` on the Desktop to Timer folder and rename it to `.env` 
If you can not find `.env.example`, please contact us to get it.

```bash filename=".env"
AZURE_SPEECH_REGION=...key...
AZURE_SPEECH_KEY=...key...
OPENAI_API_BASE_URL=...key...
OPENAI_API_KEY=...key...
```
#### 2.2.3 Run the Application
You can run project with following commands:

```bash copy
npm install 
npx expo start --web
```
If there are any errors related to dependencies, you can delete the `node_modules` folder 
and run the command again.

You should see the below content:

```
1
dataclass template HelperTemp
HelperClass Template
```

Test the voice recognition feature by clicking on the microphone and saying something. This indicates that you can use ReactGenie normally and can 
start building the Timer.

### 2.3 TimerApp with ReactGenie Overview

There are three parts that need to be completed to build the Timer App with ReactGenie:
    1. **State Code**: In the `genie` folder, implement state that controls and manages the Timer
    2. **UI Code**: In the `src` file, implement the UI for displaying Timer
    3. **Combine**: Link the State and UI code in `App.tsx` and `store.ts`.

The state code contains necessary classes for data management and logic control, 
while the UI code is responsible for building the user interface. 

```bash
-genie
    - //state code
-src
    - //UI code
-App.tsx
-store.ts
```

To integrate this with React, you will need to
    - wrap the classes with **ReactGenie** decorators for related classes or members 
    - add example voice inputs to **State code**
    - bound data types to the **UI code**
With this setup, ReactGenie will generate commands and execute them automatically when users input voice.
The execution results will be displayed automatically by ReactGenie with respect to the bounded UI interface.

We'll provide more detailed instructions in the later sections and 
you can also reference the React Genie documentation for more guidance.

**Our Recommendation:**
First plan and implement the state code. Plan the classes that will be needed. After this, 
implement the UI and integrate the state code with the UI. Then you can test the app.

In the below section, we'll demonstrate how to implement state with ReactGenie for a simple Counter App. Use 
this as reference to build the state for the Timer app. You can refer to the Requirements section earlier in these docs 
to outline the necessary elements. 

### 2.4 Write State Code

#### 2.4.1 Create Classes
We'll show you how to build classes with ReactGenie below with a simple Counter App. You can use this as a reference as you 
consider which classes you'll need to implement for a Timer app. We'll also demonstrate usage of ReactGenie decorators for 
relevant classes.

> For Counter app, we'll create a Counter class. Initialize file `Counter.ts` under `genie` folder:
```bash
-genie
    -Counter.ts
```

There are four decorators in ReactGenie: **@GenieClass**, **@GenieKey**, **@GenieProperty**, **@GenieFunction**.

**@GenieClass** allows you to declare basic information about the class by adding a description. GenieClass provides 
two types of classes that can be inherited: **DataClass** and **HelperClass**. 
<font color='red'>**Please avoid directly inheriting from GenieClass !**</font>

**DataClass** is the basic unit for data management, and an instance of a DataClass can be viewed as a record in a database. 
The properties in a DataClass can be <font color="red">a number, string, boolean, DataClass, HelperClass or a list</font>. Complex data 
types in DataClass will be stored using HelperClass, otherwise they cannot be serialized and stored correctly.

**HelperClass** is an auxiliary data storage helping the DataClass manage complex data types. 
The properties in a HelperClass can be <font color="red">a number, string, boolean, DataClass, or HelperClass, or a list</font>. 

For example, if you wanted to record an order and time, you could create an **Order (DataClass)** to store
the information and a **DateTime (HelperClass)** to manage date. **(Because you cannot put a instance of Date in 
DataClass.)** 

You can also view the sample code in `boilerplate/genie` to understand **Dataclass** and **Helperclass**.

> For a Counter, we need the DataClass.
```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
}
```

ReactGenie also provides some preset classes and automatically generated functions, we will introduce them 
in section **2.4.3**.

#### 2.4.2 Decorators
ReactGenie offers three kinds of decorators.

**@GenieKey**: GenieKey is the identifier used by ReactGenie for data management, 
and each DataClass requires a GenieKey. There are no GenieKey in a HelperClass. 
When creating a new instance of DataClass, you must provide an exclusive GenieKey.
This key will allow you to access the object.

**@GenieProperty**: GenieProperty allows user to add description to a property. 
If you wish not to serialize a property, you can add an underscore (`_`) to prevent it. 

> For Counter, we use id as its key and create other two properties: type and count.
```typescript filename="Counter.ts" {6,7}
import { GenieClass, DataClass } from "reactgenie-lib";
import { GenieKey, GenieProperty } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    @GenieKey
    @GenieProperty("The id of Counter")
    public id: number;
    @GenieProperty("The type of Counter")
    public type: string;
    @GenieProperty("The count number")
    public count: number;
    //...
}
```

**@GenieFunction**: GenieFunction can be called by ReactGenie automatically during multimodal interactions. 
You can add a description to state what this function is used for. 

<font color="red">**NOTICE:**</font>

1. Use of destructuring parameters for each function.
```typescript
// without Destructuring
example(a:number, b:number){}
// with Destructuring
example({a, b}:{a:number, b:number}){}
```
2. The constructor() should not be decorated by **@GenieFunction**
3. Each @GenieFunction needs an explicit return value.

> In our Counter class, we implement increment() and decrement() methods.

```typescript filename="Counter.ts" {11,16}
import { GenieClass, DataClass } from "reactgenie-lib";
import { GenieFunction } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    constructor({id, type}:{id:number, type:string}){
        //...
    }

    @GenieFunction("Increase the number")
    increment(): void {
        //...
    }

    @GenieFunction("Decrease the number")
    decrement(): void {
        //...
    }
}
```

#### 2.4.3 Preset Functions and Classes

ReactGenie also provides some preset classes and functions. You can use these for faster development.

**CreateObject(), GetObject(), DeleteObject()**

ReactGenie provides the above three operations for an object, among which GetObject and DeleteObject are only applicable to 
DataClass objects. 

CreateObject() will call the constructor of the class, so **the parameters of CreateObject() is the same as constructor**. Please use CreateObject instead of `new` when initializing a new object 
to ensure that the object is correctly serialized. 
<font color="red">And you need to implement your own create function based on CreateObject. </font>

Additionally, you can use GenieKey to get and delete the created object.

> We need to add our own object-related method to Counter
```typescript filename="Counter.ts" {9,15,20}
import { GenieClass, DataClass } from "reactgenie-lib";
import { GenieFunction } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    @GenieFunction()
    static CreateCounter({id, type}:{id:number, type:string}): Counter{
        Counter.CreateObject({id:id, type:type})
        return Counter.GetObject({id:id})
    }

    @GenieFunction()
    static GetCounter({id}:{id:number}): Counter{
        return Counter.GetObject({id:id})
    }

    @GenieFunction()
    DeleteCounter(): void{
        Counter.DeleteObject({id:this.id})
    }
}
```

**setup()**

The setup function is a static function of the GenieClass. You can override the setup function for initial program
 setup. ReactGenie will automatically call the function to complete the initialization. 
 
> For counter, we can set up three counters in the initialization.
```typescript filename="Counter.ts" {4}
@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    static setup() {
        Counter.CreateCounter({id:1, type:"apple"});
        Counter.CreateCounter({id:2, type:"orange"});
        Counter.CreateCounter({id:3, type:"banana"});
    }
}
```

**All(), Current()**

All() can get an array of all instances of a specific class and 
Current() can get the currently active target based on user clicks. 

You may not need Current() when writing state code, but you may use it when providing prompt examples.

Only dataclass has All() and Current().

<font color="red">NOTICE: All() and Current() will be generated during execution, so you may receive a warning that 
the function does not exist when you are writing code. You can just ignore it.</font>

> For example, you can automatically update the id for a new counter
```typescript filename="Counter.ts" {6}
@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    @GenieFunction()
    static CreateCounter({type}:{type:string}): Counter{
        const id = Counter.All().length + 1;
        Counter.CreateObject({id:id, type:type})
        return Counter.GetObject({id:id})
    }
    //...
}
```

ReactGenie has two preset class <font color='red'>**DateTime**</font> and <font color='red'>**TimeDelta**</font>, they are both **HelperClass** objects. 
You can use these to help you build the Timer or you can build your own time management. You can check the **Preset Class** section to get more information about them.

Here we list some function you might need.
```typescript filename="TimeDelta"
//property
    public hour: number;    // an integer representing hours
    public minute: number;  // an integer representing minutes
    public second: number;  // an integer representing seconds
//functions

// Returns a new instance of TimeDelta.
// Arguments are optional, defaults are 0 if not provided. 
// Use to create a new instance of TimeDelta
static CreateTimeDelta({hour?: number, minute?: number, second?: number}) : TimeDelta;
//example: TimeDelta.CreateTimeDelta({hour:0, minute:0, second:0})

// Adds an offset to a TimeDelta instance.
// All arguments are optional and are added to the properties of the instance
addOffset({hour?: number, minute?: number, second?: number});
//example: td.addOffset({hour:1, minute:0, second:0})

// Sets time to a TimeDelta instance.
// All arguments are optional and are seted to the properties of the instance
setTime({hour?: number, minute?: number, second?: number});
//example: td.setTime({hour:1, minute:0, second:0})

// Returns the total amount of time left in seconds.
getLeftSecond():number;
//example: td.getLeftSecond()

//Get the cotent of TimeDelta
toString():string;
//example: td.toString()
```
```typescript filename="DateTime"
static today() : DateTime // Returns today's date as a DateTime object
//example: DateTime.today()

//Get the cotent of DateTime
toString():string;
//example: dt.toString()
```
### 2.5 Write UI code
After completing the state code, we need to consider what kind of interactive UI 
to build. We recommend considering the data content displayed when constructing the page.

> For Counter, we may need an UI to display the content of a counter, and an UI to display 
a list of counters. They correspond to an object and a list of objects.

```bash
-src
    -CounterView.tsx
    -CounterListView.tsx
```

To save your development time, we provide you with UI-related snippets. 
Please refer to them for React and CSS code for the Timer app.

Disclaimer: the below code snippets only consist of React/Typescript and CSS. You will need to integrate 
ReactGenie yourself for this to be fully functional.

Before we get started, here's the file heirarchy for UI code:
```
--src
----commonStyles.ts
----NewTimerForm.tsx
----TimerItem.tsx
----TimerView.tsx
--App.tsx
```

#### commonStyles.ts
Copy the below styles into new file `src/commonStyles.ts`

<details>
  <summary> commonStyles.ts </summary>
  ```js copy
import {StyleSheet} from "react-native";

const font = {
    fontFamily: 'Tahoma',
    letterSpacing: 1.3,
}

export const textStyles = StyleSheet.create({
    heading: {
        ...font,
        letterSpacing: 1.3,
        color: 'white',
        fontSize: 50,
        fontWeight: '600',
    },
    heading2: {
        ...font,
        color: '#074057',
        fontWeight: '600',
        fontSize: 35,
    },
    heading3: {
        ...font,
        color: '#074057',
        fontWeight: '600',
        fontSize: 35,
    },
    label: {
        ...font,
        color: 'white',
        marginTop: 20,
        marginBottom: 10,
    },
    text: {
        ...font,
        fontSize: 16,
        color: '#455055',
    },
    subtitle: {
        ...font,
    }
})

export const commonStyles = StyleSheet.create({
    // Containers
    appContainer: {
        backgroundColor: '#0b3f55',
        paddingLeft: '10%',
        paddingRight: '10%',
        minHeight: '100%',
    },
    mainContainer: {
        flex: 1,
        paddingLeft: '10%',
        paddingRight: '10%',
    },
    timerViewContainer: {
        marginTop: 20,
        marginBottom: 20,
    },
    timerItemContainer: {
        flex: 1,
        width: '100%',
        marginTop: 20,
        padding: 20,
        borderRadius: 6,
        backgroundColor: '#e7f9ff',
        textAlignVertical: 'center',
    },
    timerFormContainer: {
        textAlign: 'center',
        height: '100%',
        width: '100%',
        alignItems: 'center',
        justifyContent: 'center',
        display: 'flex',
        flexDirection: 'column',
    },
    sectionContainer: {
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'flex-start',
        marginBottom: 20,
        width: '100%',
    },
    // Common Elements
    button: {
        width: '100%',
        padding: 10,
        border: 'none',
        cursor: 'pointer',
        backgroundColor: '#5a8ca1',
        color: '#e6f8fe',
        fontWeight: 'bold',
        fontSize: "28px",
        borderRadius: 6,
        marginTop: 20,
        ...font
    },
    inline: {
        flex: 2,
        width: '100%',
        justifyContent: 'space-between',
        height: '100%',
        flexDirection: 'row',
        marginBottom: 10,
    },
    // Add New Timer Form
    numericInputContainer: {
        alignItems: 'center',
        justifyContent: 'center',
    },
    numericInput: {
        ...textStyles.heading,
        padding: 10,
        margin: 2,
        border: 'none',
        textAlign: 'center',
        backgroundColor: 'transparent',
    },
    textInput: {
        ...textStyles.text,
        padding: 15,
        border: 'none',
        width: 'calc(100% - 30px)',
        backgroundColor: '#c7f1ff',
        borderRadius: 6,
    },
});
```
</details>

#### NewTimerForm.tsx
Use the below UI to build the New Timer Form in `src/NewTimerForm.tsx`
<details>
  <summary> NewTimerForm.tsx </summary>
```js copy
import { AppNavigator } from '../App';
import React, { useState } from 'react';
import { textStyles, commonStyles } from './commonStyles';


const NewTimerFormImpl = (props: {id: string}) => {
     // Your genie code here

    return (
        <div style={commonStyles.appContainer}>
            <div style={commonStyles.timerFormContainer}>

                <div style={commonStyles.numericInputContainer}>
                    <input style={commonStyles.numericInput} type='number' min={0} max={60} value={/*your code*/} onChange={(e) => {/*use e.target.value to get value*/}}/>
                    <label style={textStyles.heading}> : </label>
                    <input style={commonStyles.numericInput}  type='number' min={0} max={60} value={/*your code*/}  onChange={(e) => {/*your code*/}} />
                    <label style={textStyles.heading}> : </label>
                    <input style={commonStyles.numericInput}  type='number' min={0} max={60} value={/*your code*/}  onChange={(e) => {/*your code*/}} />
                </div>

                <div style={commonStyles.sectionContainer}>
                    <label style={textStyles.label}>Title </label>
                    <input style={commonStyles.textInput} type='text' size={20} value={/*your code*/} onChange={(e)=> {/*your code*/}} ></input>
                    <label style={textStyles.label}>Description </label>
                    <input style={commonStyles.textInput} type='text' size={20} value={/*your code*/} onChange={(e)=> {/*your code*/}} ></input>
                </div>

                <button style={commonStyles.button} onClick={/*Do Something*/}>Back</button>
                <button style={commonStyles.button} onClick={/*Do Something*/}>Add Timer</button>

            </div>
        </div>
    );
};

export const NewTimerForm = //ADD YOUR CODE HERE

```
</details>

#### TimerItem.tsx
TimerItem is an item in TimerList.
<details>
<summary> TimerItem.tsx </summary>
```js copy
import {AppNavigator} from "../App";
import React, {useEffect, useState} from "react";
import {Pressable, Text, View} from "react-native";
import { commonStyles, textStyles } from './commonStyles';

const TimerItemImpl = (props: {id: string}) => {
    const [actionButtonText, setActionButtonText] = useState("Start");
     // Your genie code here

    useEffect(() => {
        // If the timer is 0, we don't need to decrease it further
        // Your code here

        const intervalId = setInterval(() => {
            // Your code here
            // Will be executed every 1000ms
        }, 1000);

        // Cleanup function to clear the setInterval when timer stop/unmount
        return () => clearInterval(intervalId);
    }, [// Your code here
        ]);
   
    return (
        <View style={commonStyles.timerItemContainer}>

            <Pressable onPress={() => {AppNavigator.push('TimerModal', {id: props.id})}}>
                <View style={commonStyles.inline}>
                    <Text style={textStyles.heading2}> // Your code here</Text>
                    <Text style={textStyles.heading3}> // Your code here </Text>
                </View>
                <View style={commonStyles.inline}>
                    <Text style={textStyles.text}> // Your code here </Text>
                    <Text style={textStyles.text}> // Your code here </Text>
                </View>
            </Pressable>

            <button style={commonStyles.button} onClick={/*Your code here*/}>{actionButtonText}</button>
        </View>
    );
};

export const TimerItem = // Your code here

```
</details>

#### TimerView.tsx
<details>
<summary> TimerView.tsx </summary>
```js copy
import React from "react";
import {AppNavigator} from "../App";
import {Timer} from "../genie/Timer";
import {View} from "react-native";
import {useGenieSelector, genieDispatch} from "reactgenie-lib";
import { commonStyles } from "./commonStyles";
import { TimerItem } from "./TimerItem";

export const TimerViewImp = (props: { elements: { id: string }[]}) => {

    return (
        <View style={commonStyles.appContainer}>
            <View>
            <div style={commonStyles.timerViewContainer}>
                <button style={commonStyles.button} onClick={() => 
                
                // Your code here
                
            }>Add New Timer</button>
            </div>
            {
                props.elements.map((element) => {
                        return <TimerItem id={element.id} key={element.id}/>
                })
            }
            </View>
        </View>
    )
}

export const TimerView = // Your code here

```
</details>

You can use `AppNavigator.push('TimerModal', {id: timer.id})` to open the timer modal when `Add New Timer` button is clicked.

#### App.tsx
<details>
<summary> App.tsx </summary>
```js
import React, { default as ReactFromImport } from "react";
import { default as ReactReduxFromImport, Provider } from "react-redux";
import { NativeStackScreenProps } from "@react-navigation/native-stack";
import { StackNavigationOptions } from "@react-navigation/stack/lib/typescript/src/types";
import { CardStyleInterpolators, createStackNavigator, HeaderStyleInterpolators } from '@react-navigation/stack';

import ENV from "./config";
import { reactGenieStore } from "./store";

import { TimerView } from "./src/TimerView";
import { NewTimerForm } from "./src/NewTimerForm";


console.log("React is ReactFromModule", ReactFromModule === ReactFromImport);
console.log(
  "ReactRedux is ReactReduxFromModule: ",
  ReactReduxFromImport === ReactReduxFromModule
);

export let AppNavigator: any = null;

type Props = NativeStackScreenProps<any, any>

const TimerTab = ({route, navigation}: Props) => {
    AppNavigator = navigation
    const elements; // Your code
    return (
        <TimerView elements={elements}/>
    )
}

const TimerModalTab = ({route, navigation}: Props) => {
    AppNavigator = navigation
    return (
          <NewTimerForm {...route.params}/>
    )
}

const cardStyle: StackNavigationOptions = {
    presentation: 'card' ,
    animationEnabled: true,
    headerStyleInterpolator: HeaderStyleInterpolators.forUIKit,
    cardStyleInterpolator: CardStyleInterpolators.forHorizontalIOS
}

const modalStyle: StackNavigationOptions = {
    presentation: 'modal' ,
    animationEnabled: true,
    headerStyleInterpolator: HeaderStyleInterpolators.forUIKit,
    cardStyleInterpolator: CardStyleInterpolators.forModalPresentationIOS,
    headerShown: false,
    animationTypeForReplace: 'pop',
}

const App = () => {
    let TimerStack = () => {
        let TimerNavigator = createStackNavigator();
        return (
            <TimerNavigator.Navigator screenOptions={{
                headerShown: true
            }}>
                <TimerNavigator.Screen name="Timers" component={TimerTab} options={cardStyle}/>
                <TimerNavigator.Screen name="TimerModal" component={TimerModalTab} options={modalStyle}  />
            
            </TimerNavigator.Navigator >
        );
    }

  return (
    // Your code here
          <TimerStack/>
    // Your code here
  );
};

export default App;
```
</details>

<font color="red">NOTICE:</font>
1. To achieve automatic UI generation from ReactGenie, the code is divided into two 
parts. The first part involves the specific implementation 
of the UI, while the second part deals with binding the UI with data types.

```typescript
import {GenieClassInterface} from "reactgenie-lib"
//implementation
const CounterViewImpl = (props: { name: string}) => {return /* UI code */ }

//binding
export const CounterView = GenieClassInterface((counter: Counter) => `
${counter.name} Counter`, "Counter", 1)(CounterViewImpl)
```

2. Please use the useGenieSelector() to obtain ReactGenie data, and call genieDispatch() to modify the UI.

```typescript
import {useGenieSelector, genieDispatch} from "reactgenie-lib"

const counter: Counter = useGenieSelector(() => {
        return Counter.GetObject(props);
    });


<button onClick={() => genieDispatch(() => counter.decrement())}>-</button>
```

3. Please use **useState** cautiously and prioritize managing data with ReactGenie.


### 2.6 Link UI to State Code

After you complete the state code and UI code, you need to bind them together using **GenieClassInterface()** and 
set up the initialization of ReactGenie. You need to annotate the data type used for display in the corresponding UI,
 so that when ReactGenie gets the executed results, it will choose the UI to display according to the result type.

The parameters for GenieClassInterface are: <font color="red">Name(string), DataType(string), Priority(number, 
large means high priority)</font>

> For example, we can bind it like following:
```typescript filename="CounterView.tsx" {9,10}
const CounterViewImpl = (props: { name: string}) => {
    return (
        <div>
        //UI code
        </div>
    )
}

export const CounterView = GenieClassInterface((counter: Counter) => 
            `${counter.name} Counter`, "Counter", 1)(CounterViewImpl)
```
```typescript filename="CounterListView.tsx" {9}
const CounterListViewImpl = (props: { elements: { name: string }[] }) => {
    return (
        <div>
        //UI code
        </div>
    )
}

export const CounterListView = GenieClassInterface("Counter", "Counter[]")(CounterListViewImpl)
```

Then you need to include the main UI framework in `App.tsx`. 
ReactGenie UI must be implemented in `ModalityProvider`.

```typescript filename="App.tsx" {10} copy
<Provider store={reactGenieStore}>//load your own store
    <ModalityProvider
            examples={}//example prompt
            displayTranscript={true}
            codexApiKey={ENV.OPENAI_API_KEY!}
            codexApiBaseUrl={ENV.OPENAI_API_BASE_URL!}
            azureSpeechRegion={ENV.AZURE_SPEECH_REGION!}
            azureSpeechKey={ENV.AZURE_SPEECH_KEY!}
            extraPrompt={''}// extra prompt
        >
            // Your own UI
    </ModalityProvider>
</Provider>
```

And then you need to modify `store.ts` to finish initialization. 

If you overload the `setup()` function in the class, it will be automatically called in `initReactGenie()`. 
If you want to manually complete the initialization, call your initialization function after `initReactGenie()`.

```typescript filename="store.ts" copy
export const reactGenieStore = initReactGenie();
//manul set up here
//Data1.manul_setup()
//Data2.manul_setup()
```
You can also rename `stroe.ts` to whatever you want, but don't forget to import it in `App.tsx`


### 2.7 Add Examples and Test
Finally, you need to add usage instances for your program to help LLM correctly generate 
executable results. You can provide examples of relevant function usage in each class and then add it to ModalityProvider.

> For counters, it may be just like this:
```typescript filename="Counter.ts"
export const CounterExamples = [
{
    user_utterance: "increment",
    example_parsed: "Counter.Current().increment()",
},
{
    user_utterance: "show me all vegetables counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "vegetable")',
},
{
    user_utterance: "increase me all fruit counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "fruit").increment()',
}]
```
```typescript filename="App.tsx" copy
import { CounterExamples } from "./genie/counter";

<ModalityProvider
        examples={CounterExamples}//example prompt
        //...
```

<font color="red">NOTICE:</font>
1. The parameters in the cases should not be Destructuring
```typescript
//Right
"Couter.CreateCounter(type:\"fruit\")" 
//Wrong
//"Couter.CreateCounter({type:\"fruit\"})"
```

2. ReactGenie supports some filtering operations on arrays.

**matching(field, value), equal(field, value)**

**between(field, from, to), sort(field, ascending)**
Note that the field passed to sort() and between() should have a static compare() function.

**contains(field, value)**
The contains() returns the member whose field value contains the given value.

All this filtering operations return a array.

3. ReactGenie supports some querying operations on arrays.

ReactGenie allows developers to access the properties and functions of list members during execution. 
This can be used directly to access the properties of the list members.

```typescript copy
{
    user_utterance: "Show me all counters type",
    example_parsed: 'Counter.All().type',
  },
  {
    user_utterance: "Delete all fruit counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "fruit").DeleteCounter()',
  },
```



## 3. Questionnaire 
Before concluding the study, we would appreciate your feedback on the experiment and the ReactGenie library. Please complete the questionnaire below.

<font color='red'>Edit link</font>
[**→ Questionnaire for Developer Study**](https://docs.google.com/forms/d/e/1FAIpQLSfns89iM7uSktc2DTEOpl4KEXrf3S3myB3Oq3d0Cprnw-EurQ/viewform?usp=sf_link)