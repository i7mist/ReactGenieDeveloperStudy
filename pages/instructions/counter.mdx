## 2. Tutorial: Counter
Welcome to the Counter app tutorial. This page will introduce you to all the ReactGenie concepts you'll need for this study and guide you in building a simple Counter with ReactGenie.

### 2.1 ReactGenie Overview
We'll start with a brief introduction to the ReactGenie framework to help you understand how to build applications.

Each app built with ReactGenie, as a multimodal application, consists of three parts:

1. **State Code**: This is used to control and manage the app, such as managing data and executing functions. It is written in the <font color="red">`genie`</font> folder.

2. **UI Code**: This is used to display information and interact with the user. It is written in the <font color="red">`src`</font> folder.

3. **Combine**: This involves linking the State and UI code in <font color="red">`App.tsx`</font> and <font color="red">`store.ts`</font>.

For example, the state code for the upcoming Counter includes the Counter class for count management, while the UI code CounterView is for displaying the specific counter interface.

 ```bash {2,5}
-genie
    - //state code
    - Counter.ts
-src
    - //UI code
    - CounterView.tsx
    - CounterListView.tsx
-App.tsx
-store.ts
```

We'll provide more detailed instructions in the later sections, and you can also refer to the React Genie documentation for additional guidance.

In the following section, we'll demonstrate how to implement a simple Counter App with ReactGenie.
We'll follow the same path: starting from state code to UI code, and finally linking them together.

### 2.2 Environment Check
We have prepared you with a starter project called <font color="red">`ReactGenieCounter`</font> on the desktop.

We will construct a new Counter using this starter project.
To run the starter ReactGenie project, you can use the following commands:

```bash copy
npm install 
npx expo start --web 
```

You should see the following content in the openend browser:

```
1
dataclass template HelperTemp
HelperClass Template
```

Note that the ReactGenie framework provides a microphone button on the bottom right of the webpage.
This button allows user to talk to the app in addition to using the typical graphical user interface.

### 2.3 Create state classes
First, we need to determine which classes we need to implement for a Counter app.

For the Counter app, we'll create a Counter class. Initialize the file <font color="red">`Counter.ts`</font> under the <font color="red">`genie`</font> folder:
```bash
-genie
    -Counter.ts
```

```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass, int } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    public name: string;
    public type: string;
    public count: int;
}
```

Note that, a state class in ReactGenie has to extend <font color="red">`DataClass`</font> and be annotated with <font color="red">`@GenieClass("{description of the class}")`</font> to help ReactGenie better understand the role of the class.
In the counter, we create three class properties type, name, and count.

Another thing to keep in mind is that ReactGenie will handle the creation, management, update, and storage of all state classes (<font color="red">`DataClass`</font>es), so we only support primitive types (e.g., <font color="red">`string`</font>, <font color="red">`int`</font>, <font color="red">`float`</font>, <font color="red">`boolean`</font>), arrays of primitive types, compound types (e.g., <font color="red">`DateTime`</font> and <font color="red">`TimeDelta`</font>), and arrays of compound types.

There may be many properties in a class, and we only want to expose some of them to ReactGenie for user to interact with them multimodally.
In ReactGenie, this is done through annotating the properties with <font color="red">`@GenieProperty("{description of the property}")`</font>.

```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass, GenieProperty, int } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    @GenieProperty("The name of object that you want to count")
    public name: string;
    @GenieProperty("The type of objects (vegetable, fruit, ...)")
    public type: string;
    @GenieProperty()
    public count: int;
}
```

Another thing is required for a <font color="red">`DataClass`</font> is that it has to have a key for ReactGenie to manage the data.
The key is like key column in a database, it has to be unique for each instance of the class.
In ReactGenie, this is done through annotating the key with <font color="red">`@GenieKey`</font>.

```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass, GenieKey, GenieProperty, int } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    @GenieKey
    public id: int;

    @GenieProperty("The name of object that you want to count")
    public name: string;
    @GenieProperty("The type of objects (vegetable, fruit, ...)")
    public type: string;
    @GenieProperty()
    public count: int;
}
```

To recap, a state class (<font color="red">`DataClass`</font>) in ReactGenie have to have the following three things:
* <font color="red">`@GenieClass("{description of the class}")`</font> and extends <font color="red">`DataClass`</font>
* <font color="red">`@GenieProperty("{description of the property}")`</font>: properties that you want to expose to ReactGenie
* <font color="red">`@GenieKey`</font>: a unique key for each instance of the class

### 2.4 State class management

Similar to TypeScript, ReactGenie <font color="red">`DataClass`</font>es need a constructor.

```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass, GenieKey, GenieProperty, int } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    @GenieKey
    @GenieProperty()
    public id:int;

    @GenieProperty()
    public name: string;
    @GenieProperty()
    public type: string;
    @GenieProperty()
    public count: int;

    constructor({id, name, type, count = 0}: {id: int, name: string, type: string, count?: int}) {
        super({})
        this.id = id;
        this.name = name;
        this.type = type;
        this.count = count
    }
}
```

Note that for <font color="red">`DataClass`</font>, all function parameters have to be destructured, this allows you to have parameters that are optional.

```typescript
// without Destructuring
function example(a: int, b: int){}
// with Destructuring
function example({a, b}: {a: int, b: int}){}
// with Destructuring and default value
function example({a, b = 0}: {a: int, b?: int}){}
```

Note that even with the constructor implemented, you should avoid directly calling the constructor like:
```typescript
const counter = new Counter({id: 1, name: "apple", type: "fruit", count: 0})
```
Objects created like this will not be automatically tracked by ReactGenie.
Instead, ReactGenie provides the three static functions below to help you manage the object,
**CreateObject(), GetObject(), DeleteObject(), All()**.

<font color="red">`CreateObject()`</font> will call the constructor of the class, so **the parameters of CreateObject() is the same as constructor**.
<font color="red">`GetObject()`</font> allows you to access a object through its <font color="red">`GenieKey`</font>.
<font color="red">`All()`</font> allows you to get an array of all instances of a specific class.
<font color="red">`DeleteObject()`</font> allows you to delete a object through its <font color="red">`GenieKey`</font>.

For example:
```typescript filename="Counter.ts" {4}
const appleCounter = Counter.CreateObject({id: 1, name: "apple", type: "fruit", count: 0})
const getAppleCounter = Counter.GetObject({id: 1}) // getAppleCounter === appleCounter
const allCounters = Counter.All() // allCounters === [appleCounter]
Counter.DeleteObject({id: 1})
const allCountersAfterDelete = Counter.All() // allCountersAfterDelete === []
```

<font color="red">Note that only `All()` is automatically exposed to multimodal interactions.</font>
If you want to allow user to create a counter while using the app, you need to create a function for it.

For example, if we want to allow users to say "Create a apple counter", we need to create a function like:
```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass, GenieKey, GenieProperty, GenieFunction, int } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    //...

    constructor({id, name, type, count=0}:{id:int, name:string, type:string, count?:int}) {
        super({})
        this.id = id;
        this.name = name;
        this.type = type;
        this.count = count
    }

    @GenieFunction()
    static CreateCounter({name, type, count=0}: {name:string, type:string, count?:int}): Counter {
      const id = Counter.All().length+1;
      return Counter.CreateObject({id: id, name: name, type: type, count: count})
    }
}
```


### 2.5 Setup placeholder values
ReactGenie provides you with class initialization settings, where you can set static variables for the class or create placeholder objects.
The setup() function is a static function of the GenieClass. You can override the setup function for initial program
 setup. ReactGenie will automatically call the function to complete the initialization. 

> For counter, we can set up three counters in the initialization.
```typescript filename="Counter.ts" {4}
@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    static setup() {
        Counter.CreateCounter({name:"apple", type:"fruit"});
        Counter.CreateCounter({name:"orange", type:"fruit"});
        Counter.CreateCounter({name:"potato", type:"vegetable"});
    }
}
```
### 2.6 Add you own functions
Next, you can create more functionalities for your class.
we can creat delete, increase, and decrease functions.
```typescript filename="Counter.ts" 
@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    
    @GenieFunction()
    delete(): void {
        Counter.DeleteObject({id: this.id});
    }

    @GenieFunction()
    increment(): void {
        this.count = this.count + 1;
    }

    @GenieFunction()
    decrement(): void {
        this.count -= 1;
    }
}
```

Note that similar to <font color="red">`GenieProperty`</font>, <font color="red">`GenieFunction`</font> is used to expose functions to ReactGenie that users can increment and decrement the counter via multimodal interactions.

The parameters of <font color="red">`GenieFunction`</font> should also be destructured and the return value should be explicit, but it can be explicit <font color="red">`void`</font>.

Of course, you can also create functions to set names, types, etc., to support more possible features.
Here we get a example state code for Counter:
<details>
<summary>Counter.ts</summary>
```typescript
import { GenieClass, DataClass, GenieKey, GenieProperty, GenieFunction, int } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    //DataClass need a Key
    @GenieKey
    @GenieProperty()
    public id: int;

    @GenieProperty()
    public name: string;
    @GenieProperty()
    public type: string;
    @GenieProperty()
    public count: int;

    constructor({id, name, type, count=0}:{id: int, name: string, type: string, count?: int}) {
        super({})
        this.id = id;
        this.name = name;
        this.type = type;
        this.count = count
    }

    //Create Function
    @GenieFunction()
    static CreateCounter({name, type, count=0}: {name: string, type: string, count?: int}): Counter {
      const id = Counter.All().length+1;
      Counter.CreateObject({id: id, name: name, type: type, count: count})
      return Counter.GetObject({id: id});
    }

    //Initialization
    static setup() {
        Counter.CreateCounter({name: "apple", type: "fruit"});
        Counter.CreateCounter({name: "orange", type: "fruit"});
        Counter.CreateCounter({name: "potato", type: "vegetable"});
    }

    //Your own functions
    @GenieFunction()
    delete(): void {
        Counter.DeleteObject({id:this.id});
    }

    @GenieFunction()
    increment(): void {
        this.count = this.count + 1;
    }

    @GenieFunction()
    decrement(): void {
        this.count -= 1;
    }
}
```
</details>

### 2.6 Write UI code

After completing the state code, we need to consider what kind of graphical UI interface to build.
We recommend considering what data classes need to be represented when constructing the page.

> For Counter, we need an UI to display all the Counters.
```bash
-src
    -CounterView.tsx
    -CounterListView.tsx
```

Like React, you need to implement the UI interface in the form of a component. 
In addition, you need to bind this component with a specific data type so that when ReactGenie obtains the execution results, it will use the page you specified for display.

So the code is divided into two parts.
The first part involves the specific implementation of the UI, while the second part deals with binding the UI with data types.

Let's start by writing the implementation of UI. 
We created two components separately used to display a Counter and a Counter list.

Don't forget to import <font color="red">`React`</font> in the <font color="red">`.tsx`</font> file
```typescript filename="CounterView.tsx"
import React from "react";
const CounterViewImpl = (props: { id: number}) => {
    
    return (
        <div>
            <label>[{/*value*/}]</label> <br/> <label>{/*value*/}: </label> <br/> <label> {/*value*/}</label>
            <button onClick={() => {/*function*/}}>+</button>
            <button onClick={() => {/*function*/}}>-</button>
        </div>
    )
}
```
```typescript filename="CounterListView.tsx"
import React from "react";
import { CounterView } from "./CounterView";

const CounterListViewImpl = (props: { elements: { id: number }[] }) => {
    return (
        <div>
            {
                props.elements.map((element) => {
                    return <CounterView id={element.id} key={element.id}/>
                })
            }
        </div>
    )
}
```
Now, with basic UI code, we need to use two functions to obtain and modify the values of the ReactGenie object.

<font color="red">`useGenieSelector()`</font>: wrapper function used to access ReactGenie data

<font color="red">`genieDispatch()`</font>: wrapper function used when modifying the ReactGenie data or calling a function

We can obtain ReactGenie object data based on the parameters passed in by the component, 
and modify the data according to user operations.

```typescript filename="CounterView.tsx"
import React from "react";
import { Counter } from "../genie/Counter";
import { useGenieSelector, genieDispatch } from 'reactgenie-lib'

const CounterViewImpl = (props: { id: number}) => {
    const counter: Counter = useGenieSelector(() => {
        return Counter.GetObject(props);
    });
    const counterName = useGenieSelector(() => {
        return counter.name;
    });
    const counterValue = useGenieSelector(() => {
        return counter.count;
    });
    const counterType = useGenieSelector(() => {
        return counter.type;
    });
    return (
        <div>
            <label>[{counterType}]</label> <br/> <label>{counterName}: </label> <br/> <label> {counterValue}</label>
            <button onClick={() => genieDispatch(() => counter.increment())}>+</button>
            <button onClick={() => genieDispatch(() => counter.decrement())}>-</button>
        </div>
    )
}
```

<font color="red">Please use **useState** cautiously and prioritize managing data with ReactGenie.
Don't store data in the UI, please use state code to store data and call the data 
in the UI. </font>

### 2.7 Link UI to State Code

After we complete the state code and UI code, we need to bind them together using **GenieClassInterface()** and 
set up the initialization of ReactGenie. You need to annotate the data type used for display in the corresponding UI,
 so that when ReactGenie gets the executed results, it will choose the UI to display according to the result type.

The parameters for GenieClassInterface are: <font color="red">PageTitle(string), DataType(string), Priority(number, 
large means high priority)</font>

We can bind the counter and counter list to the UI code

```typescript filename="CounterView.tsx" {9,10}
import { GenieClassInterface } from 'reactgenie-lib'

const CounterViewImpl = (props: { id: number}) => {/*UI code*/}

export const CounterView = GenieClassInterface((counter: Counter) => 
            `${counter.name} Counter`, "Counter", 1)(CounterViewImpl)
```
```typescript filename="CounterListView.tsx" {9}
import { GenieClassInterface } from 'reactgenie-lib'

const CounterListViewImpl = (props: { elements: { id: number }[] }) => {/*UI code*/}

export const CounterListView = GenieClassInterface("Counters", "Counter[]",1)(CounterListViewImpl)
```

So far, we have completed the implementation of the UI code and their binding with the corresponding data types.

Then we need to modify <font color="red">`store.ts`</font> to finish initialization. 
If we overload the <font color="red">`setup()`</font> function in the class, it will be automatically called in <font color="red">`initReactGenie()`</font>. 
If we want to manually complete the initialization, call our initialization function after <font color="red">`initReactGenie()`</font>.

```typescript filename="store.ts" copy
export const reactGenieStore = initReactGenie();
```
You can also rename <font color="red">`store.ts`</font> to whatever you want, but don't forget to import it in <font color="red">`App.tsx`</font> and use it with the Provider


And then we need to include the main UI framework in <font color="red">`App.tsx`</font>. 
ReactGenie UI must be implemented in <font color="red">`ModalityProvider`</font>.

```typescript filename="App.tsx"  copy
import React from "react";
import { reactGenieStore } from "./store";
import { ModalityProvider, useGenieSelector } from "reactgenie-lib";
import { Counter } from "./genie/Counter";
import { Provider } from "react-redux";
import ENV from "./config";
import { CounterListView } from "./src/CounterListView";

const CounterList = () => {
    const allview = useGenieSelector(() => {
        return Counter.All();
    });
    return(
        <CounterListView elements={allview} />
    )
}
const App = () => {
    return(
        <Provider store={reactGenieStore}>//load your own store
            <ModalityProvider
                    examples={}//example prompt
                    displayTranscript={true}
                    codexApiKey={ENV.OPENAI_API_KEY!}
                    codexApiBaseUrl={ENV.OPENAI_API_BASE_URL!}
                    azureSpeechRegion={ENV.AZURE_SPEECH_REGION!}
                    azureSpeechKey={ENV.AZURE_SPEECH_KEY!}
                    extraPrompt={''}// extra prompt
                >
                <CounterList/> // you UI code
            </ModalityProvider>
        </Provider>
    )}
    export default App;
```

### 2.8 Add Examples and Test
Finally, we need to add usage instances for your program to help LLM correctly generate 
executable results. We can provide examples of relevant function usage in each class and then add it to ModalityProvider.


 <font color="red">The parameters in the cases are different from the functions, they should not be Destructuring</font>
```typescript
//Right
"Couter.CreateCounter(type:\"fruit\")" 
//Wrong
//"Couter.CreateCounter({type:\"fruit\"})"
```

To help uesr achieve more interactions, ReactGenie supports some filtering operations on arrays.

**matching(field, value), equal(field, value)**

**between(field, from, to), sort(field, ascending)**
Note that the field passed to sort() and between() should have a static compare() function.

**contains(field, value)**
The contains() returns the member whose field value contains the given value.

All this filtering operations return a array.

For example:
```typescript filename="Counter.ts"
export const CounterExamples = [
{
    user_utterance: "show me all vegetables counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "vegetable")',
}]
```


ReactGenie also supports some querying operations on arrays.
ReactGenie allows developers to access the properties and functions of list members during execution. 
This can be used directly to access the properties of the list members.

```typescript copy
{
    user_utterance: "Show me all counters type",
    example_parsed: 'Counter.All().type',
  },
  {
    user_utterance: "Delete all fruit counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "fruit").DeleteCounter()',
  },
```
Another function is built by ReactGenie to provide rich multimodal interactions is **Current()**.
Current() is automatically created for all `DataClass`es, and it returns the current object that is being interacted with.

For counter, we can add some examples for functions then import them to <font color="red">`App.tsx`</font>.
```typescript filename="Counter.ts"
export const CounterExamples = [
{
    user_utterance: "increment",
    example_parsed: "Counter.Current().increment()",
},
{
    user_utterance: "show me all vegetables counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "vegetable")',
},
{
    user_utterance: "increase me all fruit counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "fruit").increment()',
}]
```
```typescript filename="App.tsx" copy
import { CounterExamples } from "./genie/Counter";

<ModalityProvider
        examples={CounterExamples}//example prompt
        //...
```

We have completed a simple multimodal interactive application based on ReactGenie. Congratulations!




