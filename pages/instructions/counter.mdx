## 2. Tutorial: Counter
Welcome to the Counter app tutorial. This page will introduce you to all the ReactGenie concepts you'll need for this study and guide you in building a simple Counter with ReactGenie.

### 2.1 ReactGenie Overview
We'll start with a brief introduction to the ReactGenie framework to help you understand how to build applications.

Each app built with ReactGenie, as a multimodal application, consists of three parts:

1. **State Code**: This is used to control and manage the app, such as managing data and executing functions. It is written in the <font color="red">`genie`</font> folder.

2. **UI Code**: This is used to display information and interact with the user. It is written in the <font color="red">`src`</font> folder.

3. **Combine**: This involves linking the State and UI code in <font color="red">`App.tsx`</font> and <font color="red">`store.ts`</font>.

For example, the state code for the upcoming Counter includes the Counter class for count management, while the UI code CounterView is for displaying the specific counter interface.

 ```bash {2,5}
-genie
    - //state code
    - Counter.ts
-src
    - //UI code
    - CounterView.tsx
    - CounterListView.tsx
-App.tsx
-store.ts
```


To integrate this with React, you will need to:
    - Wrap the classes with **ReactGenie** decorators for related classes or members in **State code**
    - Add example voice inputs to **State code**
    - Bind data types to the **UI code**
With this setup, ReactGenie will generate commands and execute them automatically when users input voice commands. The execution results will be automatically displayed by ReactGenie according to the bound UI interface.

We'll provide more detailed instructions in the later sections, and you can also refer to the React Genie documentation for additional guidance.

In the following section, we'll demonstrate how to implement a simple Counter App with ReactGenie. We'll first plan and implement the state code, then plan the necessary classes. After this, we'll implement the UI and integrate the state code with the UI. Finally, you can test the app.
### 2.2 Environment Check
We have prepared some starter code for you in the <font color="red">`ReactGenieBoilerplate`</font> repository. 

We will construct a new Counter using this boilerplate. Before we begin, we need to ensure that ReactGenie is functioning properly. You can run the project using the following commands:

```bash copy
npm install 
npx expo start --web 
```
If you encounter any errors related to dependencies, you can delete the <font color="red">`node_modules`</font> folder and rerun the command.

You should see the following content:

```
1
dataclass template HelperTemp
HelperClass Template
```

Test the voice recognition feature by clicking on the microphone and saying something. If it works, this indicates that ReactGenie is functioning as expected and you can begin building the Timer.

### 2.3 Create GenieClass
Firstly, we need to determine which classes we need to implement for a Counter app. We'll begin with the GenieClass. GenieClass is one of the decorators in ReactGenie. The decorators in ReactGenie include: 

**@GenieClass**, **@GenieKey**, **@GenieProperty**, **@GenieFunction**.

We'll introduce the other three decorators later. For now, let's focus on **@GenieClass**.

**@GenieClass** allows you to declare basic information about the class by adding a description. GenieClass provides two types of classes that can be inherited: **DataClass** and **HelperClass**. 
<font color='red'>**Please avoid directly inheriting from GenieClass !**</font>

**DataClass** is the basic unit for data management, and an instance of a DataClass can be viewed as a record in a database. The properties in a DataClass can be <font color="red">a number, string, boolean, DataClass, HelperClass or a list of these</font>. 

If we want to have some complex data types in DataClass, then we need HelperClass, otherwise they cannot be serialized and stored correctly.

**HelperClass** is an auxiliary data storage that helps the DataClass manage complex data types. The properties in a HelperClass can be <font color="red">a number, string, boolean, DataClass, or HelperClass, or a list of them</font>. 

Let's provide an example to help you understand the relationship between DataClass and HelperClass. Suppose we want to write a food ordering app. To maintain the user's order, we need to construct an **Order DataClass**, which stores the food ordered by the users and their quantity. Simultaneously, we want to **save when the user made this order**. But we **can't directly use Date** because it is a complex data type of Typescript and **can't be a member of the DataClass**. Therefore, we can create **a HelperClass called DateTime** to save the year, month, and day and other time information. 

**HelperClass acts like an assistant to DataClass in managing complex data, hence it's called a Helper.**


> For the Counter app, we'll create a Counter class. Initialize the file <font color="red">`Counter.ts`</font> under the <font color="red">`genie`</font> folder:
```bash
-genie
    -Counter.ts
```

Counter should be a DataClass, we can add a description in the **@GenieClass** decorator to help ReactGenie better understand the role of Counter. In the counter, we create type, name, and count.

```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    public name:string;
    public type:string;
    public count:number;
}
```

Next, we are going to introduce two decorators used for property decoration.

**@GenieKey**: GenieKey is the identifier used by ReactGenie for data management, and each DataClass requires a GenieKey. There are no GenieKeys in a HelperClass. When creating a new instance of DataClass, <font color="red">you must provide an exclusive GenieKey.</font> This key will allow you to access the object.

**@GenieProperty**: GenieProperty allows users to add a description to a property. If you wish not to serialize a property, you can add an underscore (<font color="red">`_`</font>) to the variable name to prevent it. 

You may wonder in the previous example of Order and DateTime **why we don't make DateTime as a DataClass**. Here we will answer your questions with the help of GenieKey. Every DataClass contains a property that is decorated as a key, which is the index for data management. **We can directly access data in the ReactGenie database using the key.** As for the HelperClass, we often access it through the DataClass that owns it. For example, when we access DateTime, we find the order from the database first, and then access the time corresponding to the order, so we don't need to add a key in a HelperClass.

Here, we create an id for the counter as its key and decorate other properties with @GenieProperty.
```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass, GenieKey, GenieProperty } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    @GenieKey
    @GenieProperty()
    public id:number;

    @GenieProperty("The name of the counter")
    public name: string;
    @GenieProperty()
    public type: string;
    @GenieProperty()
    public count: number;
}
```

### 2.4 Manage Object 
Starting now, we will begin writing functions related to the counter. We will learn how to use **@GenieFunction**
 and preset functions provided by ReactGenie.

Please notice that we need to <font color="red">use destructuring parameters for each function in GenieClass.</font>
```typescript
// without Destructuring
example(a:number, b:number){}
// with Destructuring
example({a, b}:{a:number, b:number}){}
```

First, we need to understand how to use GenieClass's static functions to manage objects. If you know 
object-oriented programming, you will understand that each class has its own constructor, which we use the 
<font color="red">`new`</font> keyword when creating an instance of a class. 

GenieClass also need constructor, but we will use the object funtions in ReactGenie to replace <font color="red">`new`</font> keyword.

Now we can first create the constructor for Couter. Remember to provide GenieKey in it for DataClass.It means that <font color="red">the property modified by GenieKey cannot be optional.</font>

```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass, GenieKey, GenieProperty } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    @GenieKey
    @GenieProperty()
    public id:number;

    @GenieProperty()
    public name: string;
    @GenieProperty()
    public type: string;
    @GenieProperty()
    public count: number;

    constructor({id, name, type, count=0}:{id:number, name:string, type:string, count?:number}) {
        super({})
        this.id = id;
        this.name = name;
        this.type = type;
        this.count = count
    }
}
```

Before using the functions of ReactGenie, we first need to introduce @GenieFunction, which is also the last decorator of ReactGenie.

**@GenieFunction**: If you want ReactGenie to access or call functions, use GenieFunction to decorate them. 
GenieFunction can be called by ReactGenie automatically during multimodal interactions. 
You can also add a description to state what this function is used for.

<font color="red">Please notic that the function decorate with @GenieFunction must have a explicit return value.</font>
(It can be explicit <font color="red">`void`</font>)

OK, now let's back to object management. ReactGenie provides the above three operations for an object,
**they are all static members of GenieClass**. 

**CreateObject(), GetObject(), DeleteObject()**


CreateObject() will call the constructor of the class, so **the parameters of CreateObject() is the same as constructor**. 
The difference between CreateObject and <font color="red">`new`</font> is that you can only get a new instance with <font color="red">`new`</font>,
but with CreateObject() you can store it in ReactGenie. So please use CreateObject instead of `new` when initializing a new object. 

After you create a object through CreateObject(), you can access it by its GenieKey member, so that why we have a 
GenieKey in DataClass. We can use GenieKey to get and delete the object, but only for instances of DataClass.

<font color="red">Please notice that we need to implement your own create function based on CreateObject. </font> This is for 
multimodal interactions and we can also automatically generate GenieKey in our own function. The create function should be static,
 so we can call it through class name.

So we can add a CreateCounter() to Counter:

```typescript filename="Counter.ts" {4}
import { GenieClass, DataClass, GenieKey, GenieProperty, GenieFunction } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    //...

    constructor({id, name, type, count=0}:{id:number, name:string, type:string, count?:number}) {
        super({})
        this.id = id;
        this.name = name;
        this.type = type;
        this.count = count
    }

    @GenieFunction()
    static CreateCounter({name, type, count=0}: {name:string, type:string, count?:number}): Counter {
      const id = Counter.All().length+1;
      Counter.CreateObject({id: id, name: name, type: type, count: count})
      return Counter.GetObject({id: id});
  }
}
```
You might notice that we use All() in the CreateCounter(), yeah, that's another preset fuctions in ReactGenie.

**All(), Current()**

All() can get an array of all instances of a specific class and Current() can get the currently active target based on user clicks. 
Only dataclass has All() and Current().

<font color="red">All() and Current() will be generated during execution</font>, so you may receive a warning that 
the function does not exist when you are writing code. You can just ignore it.

<font color="red">You do not need Current() when writing state code, but you can use it when providing prompt examples.</font>


### 2.5 Initialization
ReactGenie provides you with class initialization settings, where you can set static variables for the class or create initial objects.
The setup() function is a static function of the GenieClass. You can override the setup function for initial program
 setup. ReactGenie will automatically call the function to complete the initialization. 

> For counter, we can set up three counters in the initialization.
```typescript filename="Counter.ts" {4}
@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    static setup() {
        Counter.CreateCounter({name:"apple", type:"fruit"});
        Counter.CreateCounter({name:"orange", type:"fruit"});
        Counter.CreateCounter({name:"potato", type:"vegetable"});
    }
}
```
### 2.6 Add you own fuctions
We have completed the necessary content of a Counter, we have created the property in the Counter, 
and decorated them with ReactGenie declare. Afterwards, we built the constructor and implemented 
our own creation function based on the preset function, finally we created three counters in the initialization.

Next, we need to create our own functions to support more functions, taking counter as an example, 
we can creat delete, increase, and decrease functions.
```typescript filename="Counter.ts" {4}
@GenieClass("A counter example")
export class Counter extends DataClass{
    //...
    
    @GenieFunction()
    delete(): void {
        Counter.DeleteObject({id:this.id});
    }

    @GenieFunction()
    increment(): void {
        this.count = this.count + 1;
    }

    @GenieFunction()
    decrement(): void {
        this.count -= 1;
    }
}
```

Of course, you can also create functions to set names, types, etc., to support more possible features.
Here we get a example state code for Counter:
<details>
<summary>Counter.ts</summary>
```typescript
import { GenieClass, DataClass, GenieKey, GenieProperty, GenieFunction } from "reactgenie-lib";

@GenieClass("A counter example")
export class Counter extends DataClass{
    //DataClass need a Key
    @GenieKey
    @GenieProperty()
    public id:number;

    @GenieProperty()
    public name: string;
    @GenieProperty()
    public type: string;
    @GenieProperty()
    public count: number;

    constructor({id, name, type, count=0}:{id:number, name:string, type:string, count?:number}) {
        super({})
        this.id = id;
        this.name = name;
        this.type = type;
        this.count = count
    }

    //Create Function
    @GenieFunction()
    static CreateCounter({name, type, count=0}: {name:string, type:string, count?:number}): Counter {
      const id = Counter.All().length+1;
      Counter.CreateObject({id: id, name: name, type: type, count: count})
      return Counter.GetObject({id: id});
    }

    //Initialization
    static setup() {
        Counter.CreateCounter({name:"apple", type:"fruit"});
        Counter.CreateCounter({name:"orange", type:"fruit"});
        Counter.CreateCounter({name:"potato", type:"vegetable"});
    }

    //Your own functions
    @GenieFunction()
    delete(): void {
        Counter.DeleteObject({id:this.id});
    }

    @GenieFunction()
    increment(): void {
        this.count = this.count + 1;
    }

    @GenieFunction()
    decrement(): void {
        this.count -= 1;
    }
}
```
</details>

### 2.6 Write UI code

After completing the state code, we need to consider what kind of interactive UI 
to build. We recommend considering the data content displayed when constructing the page.

> For Counter, we need an UI to display all the Counters.
```bash
-src
    -CounterView.tsx
```

Like React, you need to implement the UI interface in the form of a component. 
In addition, you need to bind this component with a specific data type so that 
when ReactGenie obtains the execution results, it will use the page you specified for display.

So the code is divided into two 
parts. The first part involves the specific implementation 
of the UI, while the second part deals with binding the UI with data types.

Let's start by writing the implementation of UI. 
We created two components separately used to display a Counter and a Counter list.

Don't forget to import <font color="red">`React`</font> in the <font color="red">`.tsx`</font> file
```typescript filename="CounterView.tsx"
import React from "react";
const CounterViewImpl = (props: { id: number}) => {
    
    return (
        <div>
            <label>[{/*value*/}]</label> <br/> <label>{/*value*/}: </label> <br/> <label> {/*value*/}</label>
            <button onClick={() => {/*function*/}}>+</button>
            <button onClick={() => {/*function*/}}>-</button>
        </div>
    )
}
```
```typescript filename="CounterListView.tsx"
import React from "react";
const CounterListViewImpl = (props: { elements: { id: number }[] }) => {
    return (
        <div>
            {
                props.elements.map((element) => {
                    return <CounterView id={element.id} key={element.id}/>
                })
            }
        </div>
    )
}
```
We need to use two functions to obtain and modify the values of the ReactGenie object.

useGenieSelector(): obtain ReactGenie data

genieDispatch(): modify the data or call function

We can obtain ReactGenie object data based on the parameters passed in by the component, 
and modify the data according to user operations.

```typescript filename="CounterView.tsx"
import React from "react";
import { useGenieSelector, genieDispatch } from 'reactgenie-lib'

const CounterViewImpl = (props: { id: number}) => {
    const counter: Counter = useGenieSelector(() => {
        return Counter.GetObject(props);
    });
    const counterName = useGenieSelector(() => {
        return counter.name;
    });
    const counterValue = useGenieSelector(() => {
        return counter.count;
    });
    const counterType = useGenieSelector(() => {
        return counter.type;
    });
    return (
        <div>
            <label>[{counterType}]</label> <br/> <label>{counterName}: </label> <br/> <label> {counterValue}</label>
            <button onClick={() => genieDispatch(() => counter.increment())}>+</button>
            <button onClick={() => genieDispatch(() => counter.decrement())}>-</button>
        </div>
    )
}
```

<font color="red">Please use **useState** cautiously and prioritize managing data with ReactGenie.
Don't store data in the UI, please use state code to store data and call the data 
in the UI. </font>

### 2.7 Link UI to State Code

After we complete the state code and UI code, we need to bind them together using **GenieClassInterface()** and 
set up the initialization of ReactGenie. You need to annotate the data type used for display in the corresponding UI,
 so that when ReactGenie gets the executed results, it will choose the UI to display according to the result type.

The parameters for GenieClassInterface are: <font color="red">PageTitle(string), DataType(string), Priority(number, 
large means high priority)</font>

We can bind the counter and counter list to the UI code

```typescript filename="CounterView.tsx" {9,10}
import { GenieClassInterface } from 'reactgenie-lib'

const CounterViewImpl = (props: { id: number}) => {/*UI code*/}

export const CounterView = GenieClassInterface((counter: Counter) => 
            `${counter.name} Counter`, "Counter", 1)(CounterViewImpl)
```
```typescript filename="CounterListView.tsx" {9}
import { GenieClassInterface } from 'reactgenie-lib'

const CounterListViewImpl = (props: { elements: { id: number }[] }) => {/*UI code*/}

export const CounterListView = GenieClassInterface("Counters", "Counter[]",1)(CounterListViewImpl)
```

So far, we have completed the implementation of the UI code and their binding with the corresponding data types.

Then we need to modify `store.ts` to finish initialization. 
If we overload the `setup()` function in the class, it will be automatically called in `initReactGenie()`. 
If we want to manually complete the initialization, call our initialization function after `initReactGenie()`.

```typescript filename="store.ts" copy
export const reactGenieStore = initReactGenie();
//manul set up here
//Data1.manul_setup()
//Data2.manul_setup()
```
You can also rename `stroe.ts` to whatever you want, but don't forget to import it in  Provider in `App.tsx`


And then we need to include the main UI framework in `App.tsx`. 
ReactGenie UI must be implemented in `ModalityProvider`.

```typescript filename="App.tsx"  copy
import { reactGenieStore } from "./store";
import { ModalityProvider } from "reactgenie-lib";
import { useGenieSelector } from 'reactgenie-lib'

const CounterList = () => {
    const allview = useGenieSelector(() => {
        return Counter.All();
    });
    return(
        <CounterListView elements={allview} />
    )
}

<Provider store={reactGenieStore}>//load your own store
    <ModalityProvider
            examples={}//example prompt
            displayTranscript={true}
            codexApiKey={ENV.OPENAI_API_KEY!}
            codexApiBaseUrl={ENV.OPENAI_API_BASE_URL!}
            azureSpeechRegion={ENV.AZURE_SPEECH_REGION!}
            azureSpeechKey={ENV.AZURE_SPEECH_KEY!}
            extraPrompt={''}// extra prompt
        >
        <CounterList/> // you UI code
    </ModalityProvider>
</Provider>
```

### 2.8 Add Examples and Test
Finally, we need to add usage instances for your program to help LLM correctly generate 
executable results. We can provide examples of relevant function usage in each class and then add it to ModalityProvider.


 <font color="red">The parameters in the cases are different from the functions, they should not be Destructuring</font>
```typescript
//Right
"Couter.CreateCounter(type:\"fruit\")" 
//Wrong
//"Couter.CreateCounter({type:\"fruit\"})"
```

To help uesr achieve more interactions, ReactGenie supports some filtering operations on arrays.

**matching(field, value), equal(field, value)**

**between(field, from, to), sort(field, ascending)**
Note that the field passed to sort() and between() should have a static compare() function.

**contains(field, value)**
The contains() returns the member whose field value contains the given value.

All this filtering operations return a array.

For example:
```typescript filename="Counter.ts"
export const CounterExamples = [
{
    user_utterance: "show me all vegetables counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "vegetable")',
}]
```


ReactGenie also supports some querying operations on arrays.
ReactGenie allows developers to access the properties and functions of list members during execution. 
This can be used directly to access the properties of the list members.

```typescript copy
{
    user_utterance: "Show me all counters type",
    example_parsed: 'Counter.All().type',
  },
  {
    user_utterance: "Delete all fruit counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "fruit").DeleteCounter()',
  },
```


For counter, we can add some examples for functions then import them to <font color="red">`App.tsx`</font>.
```typescript filename="Counter.ts"
export const CounterExamples = [
{
    user_utterance: "increment",
    example_parsed: "Counter.Current().increment()",
},
{
    user_utterance: "show me all vegetables counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "vegetable")',
},
{
    user_utterance: "increase me all fruit counters",
    example_parsed: 'Counter.All().matching(field: .type, value: "fruit").increment()',
}]
```
```typescript filename="App.tsx" copy
import { CounterExamples } from "./genie/counter";

<ModalityProvider
        examples={CounterExamples}//example prompt
        //...
```

We have completed a simple multimodal interactive application based on ReactGenie. Congratulations!




